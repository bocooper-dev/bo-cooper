const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./DnLd7hA7.js","./Du8UmZZh.js","./BOuGH_in.js","./entry.B8R3Ctvx.css"])))=>i.map(i=>d[i]);
import{aG as e,_ as t,aH as n,aI as o,aJ as r}from"./Du8UmZZh.js";import"./BOuGH_in.js";function i(t,n){const o=function(t){const n=t.match(/FROM\s+(\w+)/);if(!n)return{};const o=e[function(e){return e.replace(/^_content_/,"")}(n[1])];return o?.fields||{}}(t),r={...n};for(const e in r)"json"===o[e]&&r[e]&&"undefined"!==r[e]&&(r[e]=JSON.parse(r[e])),"boolean"===o[e]&&"undefined"!==r[e]&&(r[e]=Boolean(r[e]));for(const e in r)"NULL"===r[e]&&(r[e]=void 0);return r}let a;const c={},s={};function l(e){async function l(e){return a||(s._=s._||async function(){if(!a){const e=await t(()=>import("./DnLd7hA7.js"),__vite__mapDeps([0,1,2,3]),import.meta.url).then(e=>e.default);globalThis.sqlite3ApiConfig={silent:!0,debug:(...e)=>console.debug(...e),warn:(...e)=>{String(e[0]).includes("OPFS sqlite3_vfs")||console.warn(...e)},error:(...e)=>console.error(...e),log:(...e)=>console.log(...e)};const n=await e();a=new n.oo1.DB}return a}(),a=await s._,Reflect.deleteProperty(s,"_")),c[String(e)]||(s[String(e)]=s[String(e)]||async function(e){if(window.sessionStorage.getItem("previewToken"))return a;let t=null;const i=`checksum_${e}`,c=`collection_${e}`;let s="matched";try{const t=a.exec({sql:`SELECT * FROM ${n.info} where id = '${i}'`,rowMode:"object",returnValue:"resultRows"}).shift();t?.version!==o[String(e)]&&(s="mismatch")}catch{s="missing"}if("matched"!==s){window.localStorage.getItem(`content_${i}`)===o[String(e)]&&(t=window.localStorage.getItem(`content_${c}`));if(!t){t=await r(void 0,String(e));try{window.localStorage.setItem(`content_${i}`,o[String(e)]),window.localStorage.setItem(`content_${c}`,t)}catch(l){console.error("Database integrity check failed, rebuilding database",l)}}const w=await async function(e,t="gzip"){const n=Uint8Array.from(atob(e),e=>e.charCodeAt(0)),o=new Response(new Blob([n])),r=o.body?.pipeThrough(new DecompressionStream(t)),i=await new Response(r).text();return JSON.parse(i)}(t);await a.exec({sql:`DROP TABLE IF EXISTS ${n[String(e)]}`}),"mismatch"===s&&await a.exec({sql:`DELETE FROM ${n.info} WHERE id = '${i}'`});for(const e of w)try{await a.exec(e)}catch(l){console.error("Error executing command",l)}}return a}(e),await s[String(e)],c[String(e)]="loaded",Reflect.deleteProperty(s,String(e))),a}return{all:async(t,n)=>(await l(e),a.exec({sql:t,bind:n,rowMode:"object",returnValue:"resultRows"}).map(e=>i(t,e))),first:async(t,n)=>(await l(e),i(t,a.exec({sql:t,bind:n,rowMode:"object",returnValue:"resultRows"}).shift())),exec:async(t,n)=>{await l(e),await a.exec({sql:t,bind:n})}}}export{l as loadDatabaseAdapter};
